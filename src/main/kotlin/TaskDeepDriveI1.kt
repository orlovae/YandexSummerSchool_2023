import kotlin.math.min

/**
На курсах повышения квалификации официанты Георгий и Нино узнали, что любое натуральное число представимо в виде
суммы различных степеней двойки единственным образом. Поэтому им пришло в голову, как можно индивидуально подбирать
количество хинкали в порции. В самом деле, почему бы не продавать порции по 1, 2, 4, 8 хинкали и так далее, чтобы
каждый мог заказать по выгодным ценам столько, сколько ему необходимо?
Обсудив нюансы, Георгий и Нино рассказали посетителю кафе Саше о специальном предложении в меню, которое состоит
из n вариантов порций: i-ый вариант (начиная с 0) представляет собой порцию из 2ei хинкали стоимостью ai рублей.
Причем из соображений адекватности цены ai⩽2ei и ai⩽ai+1.
Саше нужно хотя бы k хинкали, и, естественно, он хочет сэкономить как можно больше денег. Напишите программу,
которая выведет минимальное количество денег, которые необходимо потратить Саше по специальному предложению
Георгия и Нино, при условии, что можно покупать несколько одинаковых порций.

Формат ввода
В первой строке ввода дается одно число k (1⩽k⩽10e9) − количество хинкали, необходимых Саше. Во второй строке
находится число n (1⩽n⩽100) − количество порций, которые предлагают Георгий и Нино. В третьей строке находятся
n чисел − a0, a1, ..., an−1 (1⩽ai⩽min(2ei, 10e9) − стоимость соответствующих порций хинкали.

Формат вывода
Выведите одно число − минимальную сумму в рублях, которая необходима Саше, чтобы суммарное количество хинкали в
заказанных порциях было не меньше k.

Пример
Ввод
23
5
1 2 3 7 16
Вывод
18

Примечания
В примере порция из 1 хинкали стоит 1 рубль, из 2 хинкали − 2 рубля, из 4 хинкали − 3 рубля, из 8 хинкали − 7
рублей и из 16 хинкали 16 рублей. Выгоднее всего взять 6 порций по 4 хинкали, тем самым Саше нужно иметь хотя бы
6×3=18 рублей.
 */
class TaskDeepDriveI1 {
    private val countKhinkali = readln().toInt()
    private val sizePortionList = readln().toInt()
    private val pricePortionList = readln().split(" ").map { it.toInt() }

    init {
        var answer = Int.MAX_VALUE
        pricePortionList.forEachIndexed {i, price ->
            val tmp = twoPowI(i)
            val sumPortion = if (countKhinkali % tmp != 0) {
                (countKhinkali / tmp) + 1
            } else {
                countKhinkali / tmp
            }

            val countPrice = sumPortion * price
            answer = min(answer, countPrice)


        }
        println(answer)
    }
}

private fun twoPowI(value: Int): Int {
    var answer = 1
    for (i in 0 until  value) {
        answer *= 2
    }
    return answer
}