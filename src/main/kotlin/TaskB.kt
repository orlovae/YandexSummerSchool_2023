import kotlin.text.StringBuilder

/**
 * B. Канонический путь
 * По заданной строке, являющейся абсолютным адресом в Unix-системе, вам необходимо получить канонический адрес.
 * В Unix-системе "." соответсвутет текущей директории, ".." — родительской директории, при этом будем считать,
 * что любое количество точек подряд, большее двух, соответствует директории с таким названием (состоящем из
 * точек). "/" является разделителем вложенных директорий, причем несколько "/" подряд должны интерпретироваться
 * как один "/".
 * Канонический путь должен обладать следующими свойствами:
 * 1) всегда начинаться с одного "/"
 * 2) любые две вложенные директории разделяются ровно одним знаком "/"
 * 3) путь не заканчивается "/" (за исключением корневой директории, состоящего только из символа "/")
 * 4) в каноническом пути есть только директории, т.е. нет ни одного вхождения "." или ".." как соответствия текущей
 * или родительской директории
 *
 * Формат ввода
 * Вводится строка с абсолютным адресом, её длина не превосходит 100.
 *
 * Формат вывода
 * Выведите канонический путь.
 *
 * Пример 1
 * Ввод "/home/"
 * Вывод "/home"
 *
 * Пример 2
 * Ввод "/../"
 * Вывод "/"
 *
 * Пример 3
 * Ввод "/home//foo/"
 * Вывод "/home/foo"
 *
 * Примечания
 * В первом примере необходимо убрать "/" в конце строки
 * Во втором примере нельзя подняться выше корневой директории
 * В третьем примере несколко подряд идущих "/" должны замениться на один, а также необходимо убрать "/"
 * в конце строки
 */
class TaskB {
    private val scan = java.util.Scanner(System.`in`)
    private val inputString = scan.next()
    private val lexeme = "/"

    init {
        getCanonicalPath()
    }

    private fun getCanonicalPath() {
        val list = inputString.split(lexeme)
        val stack = ArrayDeque<String>()
        list.forEach {
            if (it != "." && it.isNotEmpty()) {
                stack.add(lexeme + it)
            }

            if (it == "..") {
                stack.removeLast()
                if (stack.lastIndex > 0) {
                    stack.removeLast()
                }
            }
        }

        if (stack.isEmpty()) {
            println(lexeme)
        } else {
            stack.forEach { print(it) }
        }
    }
}

// /a/b/c/../d
//  a b c .. d